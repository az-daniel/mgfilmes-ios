import globalAxios from 'axios';
import { assertParamExists, DUMMY_BASE_URL, setApiKeyToObject, setSearchParams, toPathString, serializeDataIfNeeded, createRequestFunction } from '../common.js';
import { operationServerMap, BaseAPI, BASE_PATH } from '../base.js';

/* tslint:disable */
/* eslint-disable */
/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit the class manually.
 *
 * Jellyfin API
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
/**
 * LibraryApi - axios parameter creator
 * @export
 */
const LibraryApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Deletes an item from the library and filesystem.
         * @param {string} itemId The item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItem: async (itemId, options = {}) => {
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('deleteItem', 'itemId', itemId);
            const localVarPath = `/Items/{itemId}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Deletes items from the library and filesystem.
         * @param {Array<string>} [ids] The item ids.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItems: async (ids, options = {}) => {
            const localVarPath = `/Items`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Gets all parents of an item.
         * @param {string} itemId The item id.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAncestors: async (itemId, userId, options = {}) => {
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('getAncestors', 'itemId', itemId);
            const localVarPath = `/Items/{itemId}/Ancestors`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Gets critic review for an item.
         * @param {string} itemId
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getCriticReviews: async (itemId, options = {}) => {
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('getCriticReviews', 'itemId', itemId);
            const localVarPath = `/Items/{itemId}/CriticReviews`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Downloads item media.
         * @param {string} itemId The item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDownload: async (itemId, options = {}) => {
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('getDownload', 'itemId', itemId);
            const localVarPath = `/Items/{itemId}/Download`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get the original file of an item.
         * @param {string} itemId The item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile: async (itemId, options = {}) => {
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('getFile', 'itemId', itemId);
            const localVarPath = `/Items/{itemId}/File`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get item counts.
         * @param {string} [userId] Optional. Get counts from a specific user\&#39;s library.
         * @param {boolean} [isFavorite] Optional. Get counts of favorite items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemCounts: async (userId, isFavorite, options = {}) => {
            const localVarPath = `/Items/Counts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (isFavorite !== undefined) {
                localVarQueryParameter['isFavorite'] = isFavorite;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Gets the library options info.
         * @param {CollectionType} [libraryContentType] Library content type.
         * @param {boolean} [isNewLibrary] Whether this is a new library.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLibraryOptionsInfo: async (libraryContentType, isNewLibrary, options = {}) => {
            const localVarPath = `/Libraries/AvailableOptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            if (libraryContentType !== undefined) {
                localVarQueryParameter['libraryContentType'] = libraryContentType;
            }
            if (isNewLibrary !== undefined) {
                localVarQueryParameter['isNewLibrary'] = isNewLibrary;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Gets all user media folders.
         * @param {boolean} [isHidden] Optional. Filter by folders that are marked hidden, or not.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMediaFolders: async (isHidden, options = {}) => {
            const localVarPath = `/Library/MediaFolders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            if (isHidden !== undefined) {
                localVarQueryParameter['isHidden'] = isHidden;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Gets a list of physical paths from virtual folders.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhysicalPaths: async (options = {}) => {
            const localVarPath = `/Library/PhysicalPaths`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Gets similar items.
         * @param {string} itemId The item id.
         * @param {Array<string>} [excludeArtistIds] Exclude artist ids.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimilarAlbums: async (itemId, excludeArtistIds, userId, limit, fields, options = {}) => {
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('getSimilarAlbums', 'itemId', itemId);
            const localVarPath = `/Albums/{itemId}/Similar`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            if (excludeArtistIds) {
                localVarQueryParameter['excludeArtistIds'] = excludeArtistIds;
            }
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (fields) {
                localVarQueryParameter['fields'] = fields;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Gets similar items.
         * @param {string} itemId The item id.
         * @param {Array<string>} [excludeArtistIds] Exclude artist ids.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimilarArtists: async (itemId, excludeArtistIds, userId, limit, fields, options = {}) => {
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('getSimilarArtists', 'itemId', itemId);
            const localVarPath = `/Artists/{itemId}/Similar`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            if (excludeArtistIds) {
                localVarQueryParameter['excludeArtistIds'] = excludeArtistIds;
            }
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (fields) {
                localVarQueryParameter['fields'] = fields;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Gets similar items.
         * @param {string} itemId The item id.
         * @param {Array<string>} [excludeArtistIds] Exclude artist ids.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimilarItems: async (itemId, excludeArtistIds, userId, limit, fields, options = {}) => {
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('getSimilarItems', 'itemId', itemId);
            const localVarPath = `/Items/{itemId}/Similar`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            if (excludeArtistIds) {
                localVarQueryParameter['excludeArtistIds'] = excludeArtistIds;
            }
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (fields) {
                localVarQueryParameter['fields'] = fields;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Gets similar items.
         * @param {string} itemId The item id.
         * @param {Array<string>} [excludeArtistIds] Exclude artist ids.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimilarMovies: async (itemId, excludeArtistIds, userId, limit, fields, options = {}) => {
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('getSimilarMovies', 'itemId', itemId);
            const localVarPath = `/Movies/{itemId}/Similar`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            if (excludeArtistIds) {
                localVarQueryParameter['excludeArtistIds'] = excludeArtistIds;
            }
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (fields) {
                localVarQueryParameter['fields'] = fields;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Gets similar items.
         * @param {string} itemId The item id.
         * @param {Array<string>} [excludeArtistIds] Exclude artist ids.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimilarShows: async (itemId, excludeArtistIds, userId, limit, fields, options = {}) => {
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('getSimilarShows', 'itemId', itemId);
            const localVarPath = `/Shows/{itemId}/Similar`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            if (excludeArtistIds) {
                localVarQueryParameter['excludeArtistIds'] = excludeArtistIds;
            }
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (fields) {
                localVarQueryParameter['fields'] = fields;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Gets similar items.
         * @param {string} itemId The item id.
         * @param {Array<string>} [excludeArtistIds] Exclude artist ids.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimilarTrailers: async (itemId, excludeArtistIds, userId, limit, fields, options = {}) => {
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('getSimilarTrailers', 'itemId', itemId);
            const localVarPath = `/Trailers/{itemId}/Similar`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            if (excludeArtistIds) {
                localVarQueryParameter['excludeArtistIds'] = excludeArtistIds;
            }
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (fields) {
                localVarQueryParameter['fields'] = fields;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get theme songs and videos for an item.
         * @param {string} itemId The item id.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {boolean} [inheritFromParent] Optional. Determines whether or not parent items should be searched for theme media.
         * @param {Array<ItemSortBy>} [sortBy] Optional. Specify one or more sort orders, comma delimited. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
         * @param {Array<SortOrder>} [sortOrder] Optional. Sort Order - Ascending, Descending.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThemeMedia: async (itemId, userId, inheritFromParent, sortBy, sortOrder, options = {}) => {
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('getThemeMedia', 'itemId', itemId);
            const localVarPath = `/Items/{itemId}/ThemeMedia`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (inheritFromParent !== undefined) {
                localVarQueryParameter['inheritFromParent'] = inheritFromParent;
            }
            if (sortBy) {
                localVarQueryParameter['sortBy'] = sortBy;
            }
            if (sortOrder) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get theme songs for an item.
         * @param {string} itemId The item id.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {boolean} [inheritFromParent] Optional. Determines whether or not parent items should be searched for theme media.
         * @param {Array<ItemSortBy>} [sortBy] Optional. Specify one or more sort orders, comma delimited. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
         * @param {Array<SortOrder>} [sortOrder] Optional. Sort Order - Ascending, Descending.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThemeSongs: async (itemId, userId, inheritFromParent, sortBy, sortOrder, options = {}) => {
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('getThemeSongs', 'itemId', itemId);
            const localVarPath = `/Items/{itemId}/ThemeSongs`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (inheritFromParent !== undefined) {
                localVarQueryParameter['inheritFromParent'] = inheritFromParent;
            }
            if (sortBy) {
                localVarQueryParameter['sortBy'] = sortBy;
            }
            if (sortOrder) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get theme videos for an item.
         * @param {string} itemId The item id.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {boolean} [inheritFromParent] Optional. Determines whether or not parent items should be searched for theme media.
         * @param {Array<ItemSortBy>} [sortBy] Optional. Specify one or more sort orders, comma delimited. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
         * @param {Array<SortOrder>} [sortOrder] Optional. Sort Order - Ascending, Descending.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThemeVideos: async (itemId, userId, inheritFromParent, sortBy, sortOrder, options = {}) => {
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('getThemeVideos', 'itemId', itemId);
            const localVarPath = `/Items/{itemId}/ThemeVideos`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (inheritFromParent !== undefined) {
                localVarQueryParameter['inheritFromParent'] = inheritFromParent;
            }
            if (sortBy) {
                localVarQueryParameter['sortBy'] = sortBy;
            }
            if (sortOrder) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Reports that new movies have been added by an external source.
         * @param {string} [tmdbId] The tmdbId.
         * @param {string} [imdbId] The imdbId.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAddedMovies: async (tmdbId, imdbId, options = {}) => {
            const localVarPath = `/Library/Movies/Added`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            if (tmdbId !== undefined) {
                localVarQueryParameter['tmdbId'] = tmdbId;
            }
            if (imdbId !== undefined) {
                localVarQueryParameter['imdbId'] = imdbId;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Reports that new episodes of a series have been added by an external source.
         * @param {string} [tvdbId] The tvdbId.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAddedSeries: async (tvdbId, options = {}) => {
            const localVarPath = `/Library/Series/Added`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            if (tvdbId !== undefined) {
                localVarQueryParameter['tvdbId'] = tvdbId;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Reports that new movies have been added by an external source.
         * @param {MediaUpdateInfoDto} mediaUpdateInfoDto The update paths.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUpdatedMedia: async (mediaUpdateInfoDto, options = {}) => {
            // verify required parameter 'mediaUpdateInfoDto' is not null or undefined
            assertParamExists('postUpdatedMedia', 'mediaUpdateInfoDto', mediaUpdateInfoDto);
            const localVarPath = `/Library/Media/Updated`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(mediaUpdateInfoDto, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Reports that new movies have been added by an external source.
         * @param {string} [tmdbId] The tmdbId.
         * @param {string} [imdbId] The imdbId.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUpdatedMovies: async (tmdbId, imdbId, options = {}) => {
            const localVarPath = `/Library/Movies/Updated`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            if (tmdbId !== undefined) {
                localVarQueryParameter['tmdbId'] = tmdbId;
            }
            if (imdbId !== undefined) {
                localVarQueryParameter['imdbId'] = imdbId;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Reports that new episodes of a series have been added by an external source.
         * @param {string} [tvdbId] The tvdbId.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUpdatedSeries: async (tvdbId, options = {}) => {
            const localVarPath = `/Library/Series/Updated`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            if (tvdbId !== undefined) {
                localVarQueryParameter['tvdbId'] = tvdbId;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Starts a library scan.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshLibrary: async (options = {}) => {
            const localVarPath = `/Library/Refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * LibraryApi - functional programming interface
 * @export
 */
const LibraryApiFp = function (configuration) {
    const localVarAxiosParamCreator = LibraryApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Deletes an item from the library and filesystem.
         * @param {string} itemId The item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItem(itemId, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteItem(itemId, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = operationServerMap['LibraryApi.deleteItem']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Deletes items from the library and filesystem.
         * @param {Array<string>} [ids] The item ids.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItems(ids, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteItems(ids, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = operationServerMap['LibraryApi.deleteItems']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Gets all parents of an item.
         * @param {string} itemId The item id.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAncestors(itemId, userId, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAncestors(itemId, userId, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = operationServerMap['LibraryApi.getAncestors']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Gets critic review for an item.
         * @param {string} itemId
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getCriticReviews(itemId, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCriticReviews(itemId, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = operationServerMap['LibraryApi.getCriticReviews']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Downloads item media.
         * @param {string} itemId The item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDownload(itemId, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDownload(itemId, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = operationServerMap['LibraryApi.getDownload']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get the original file of an item.
         * @param {string} itemId The item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFile(itemId, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFile(itemId, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = operationServerMap['LibraryApi.getFile']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get item counts.
         * @param {string} [userId] Optional. Get counts from a specific user\&#39;s library.
         * @param {boolean} [isFavorite] Optional. Get counts of favorite items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemCounts(userId, isFavorite, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItemCounts(userId, isFavorite, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = operationServerMap['LibraryApi.getItemCounts']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Gets the library options info.
         * @param {CollectionType} [libraryContentType] Library content type.
         * @param {boolean} [isNewLibrary] Whether this is a new library.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLibraryOptionsInfo(libraryContentType, isNewLibrary, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLibraryOptionsInfo(libraryContentType, isNewLibrary, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = operationServerMap['LibraryApi.getLibraryOptionsInfo']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Gets all user media folders.
         * @param {boolean} [isHidden] Optional. Filter by folders that are marked hidden, or not.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMediaFolders(isHidden, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMediaFolders(isHidden, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = operationServerMap['LibraryApi.getMediaFolders']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Gets a list of physical paths from virtual folders.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPhysicalPaths(options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPhysicalPaths(options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = operationServerMap['LibraryApi.getPhysicalPaths']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Gets similar items.
         * @param {string} itemId The item id.
         * @param {Array<string>} [excludeArtistIds] Exclude artist ids.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSimilarAlbums(itemId, excludeArtistIds, userId, limit, fields, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSimilarAlbums(itemId, excludeArtistIds, userId, limit, fields, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = operationServerMap['LibraryApi.getSimilarAlbums']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Gets similar items.
         * @param {string} itemId The item id.
         * @param {Array<string>} [excludeArtistIds] Exclude artist ids.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSimilarArtists(itemId, excludeArtistIds, userId, limit, fields, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSimilarArtists(itemId, excludeArtistIds, userId, limit, fields, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = operationServerMap['LibraryApi.getSimilarArtists']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Gets similar items.
         * @param {string} itemId The item id.
         * @param {Array<string>} [excludeArtistIds] Exclude artist ids.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSimilarItems(itemId, excludeArtistIds, userId, limit, fields, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSimilarItems(itemId, excludeArtistIds, userId, limit, fields, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = operationServerMap['LibraryApi.getSimilarItems']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Gets similar items.
         * @param {string} itemId The item id.
         * @param {Array<string>} [excludeArtistIds] Exclude artist ids.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSimilarMovies(itemId, excludeArtistIds, userId, limit, fields, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSimilarMovies(itemId, excludeArtistIds, userId, limit, fields, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = operationServerMap['LibraryApi.getSimilarMovies']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Gets similar items.
         * @param {string} itemId The item id.
         * @param {Array<string>} [excludeArtistIds] Exclude artist ids.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSimilarShows(itemId, excludeArtistIds, userId, limit, fields, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSimilarShows(itemId, excludeArtistIds, userId, limit, fields, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = operationServerMap['LibraryApi.getSimilarShows']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Gets similar items.
         * @param {string} itemId The item id.
         * @param {Array<string>} [excludeArtistIds] Exclude artist ids.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSimilarTrailers(itemId, excludeArtistIds, userId, limit, fields, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSimilarTrailers(itemId, excludeArtistIds, userId, limit, fields, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = operationServerMap['LibraryApi.getSimilarTrailers']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get theme songs and videos for an item.
         * @param {string} itemId The item id.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {boolean} [inheritFromParent] Optional. Determines whether or not parent items should be searched for theme media.
         * @param {Array<ItemSortBy>} [sortBy] Optional. Specify one or more sort orders, comma delimited. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
         * @param {Array<SortOrder>} [sortOrder] Optional. Sort Order - Ascending, Descending.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getThemeMedia(itemId, userId, inheritFromParent, sortBy, sortOrder, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.getThemeMedia(itemId, userId, inheritFromParent, sortBy, sortOrder, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = operationServerMap['LibraryApi.getThemeMedia']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get theme songs for an item.
         * @param {string} itemId The item id.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {boolean} [inheritFromParent] Optional. Determines whether or not parent items should be searched for theme media.
         * @param {Array<ItemSortBy>} [sortBy] Optional. Specify one or more sort orders, comma delimited. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
         * @param {Array<SortOrder>} [sortOrder] Optional. Sort Order - Ascending, Descending.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getThemeSongs(itemId, userId, inheritFromParent, sortBy, sortOrder, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.getThemeSongs(itemId, userId, inheritFromParent, sortBy, sortOrder, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = operationServerMap['LibraryApi.getThemeSongs']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get theme videos for an item.
         * @param {string} itemId The item id.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {boolean} [inheritFromParent] Optional. Determines whether or not parent items should be searched for theme media.
         * @param {Array<ItemSortBy>} [sortBy] Optional. Specify one or more sort orders, comma delimited. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
         * @param {Array<SortOrder>} [sortOrder] Optional. Sort Order - Ascending, Descending.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getThemeVideos(itemId, userId, inheritFromParent, sortBy, sortOrder, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.getThemeVideos(itemId, userId, inheritFromParent, sortBy, sortOrder, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = operationServerMap['LibraryApi.getThemeVideos']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Reports that new movies have been added by an external source.
         * @param {string} [tmdbId] The tmdbId.
         * @param {string} [imdbId] The imdbId.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postAddedMovies(tmdbId, imdbId, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.postAddedMovies(tmdbId, imdbId, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = operationServerMap['LibraryApi.postAddedMovies']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Reports that new episodes of a series have been added by an external source.
         * @param {string} [tvdbId] The tvdbId.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postAddedSeries(tvdbId, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.postAddedSeries(tvdbId, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = operationServerMap['LibraryApi.postAddedSeries']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Reports that new movies have been added by an external source.
         * @param {MediaUpdateInfoDto} mediaUpdateInfoDto The update paths.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUpdatedMedia(mediaUpdateInfoDto, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.postUpdatedMedia(mediaUpdateInfoDto, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = operationServerMap['LibraryApi.postUpdatedMedia']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Reports that new movies have been added by an external source.
         * @param {string} [tmdbId] The tmdbId.
         * @param {string} [imdbId] The imdbId.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUpdatedMovies(tmdbId, imdbId, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.postUpdatedMovies(tmdbId, imdbId, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = operationServerMap['LibraryApi.postUpdatedMovies']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Reports that new episodes of a series have been added by an external source.
         * @param {string} [tvdbId] The tvdbId.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUpdatedSeries(tvdbId, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.postUpdatedSeries(tvdbId, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = operationServerMap['LibraryApi.postUpdatedSeries']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Starts a library scan.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshLibrary(options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshLibrary(options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = operationServerMap['LibraryApi.refreshLibrary']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
/**
 * LibraryApi - factory interface
 * @export
 */
const LibraryApiFactory = function (configuration, basePath, axios) {
    const localVarFp = LibraryApiFp(configuration);
    return {
        /**
         *
         * @summary Deletes an item from the library and filesystem.
         * @param {LibraryApiDeleteItemRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItem(requestParameters, options) {
            return localVarFp.deleteItem(requestParameters.itemId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Deletes items from the library and filesystem.
         * @param {LibraryApiDeleteItemsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItems(requestParameters = {}, options) {
            return localVarFp.deleteItems(requestParameters.ids, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Gets all parents of an item.
         * @param {LibraryApiGetAncestorsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAncestors(requestParameters, options) {
            return localVarFp.getAncestors(requestParameters.itemId, requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Gets critic review for an item.
         * @param {LibraryApiGetCriticReviewsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getCriticReviews(requestParameters, options) {
            return localVarFp.getCriticReviews(requestParameters.itemId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Downloads item media.
         * @param {LibraryApiGetDownloadRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDownload(requestParameters, options) {
            return localVarFp.getDownload(requestParameters.itemId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get the original file of an item.
         * @param {LibraryApiGetFileRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile(requestParameters, options) {
            return localVarFp.getFile(requestParameters.itemId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get item counts.
         * @param {LibraryApiGetItemCountsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemCounts(requestParameters = {}, options) {
            return localVarFp.getItemCounts(requestParameters.userId, requestParameters.isFavorite, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Gets the library options info.
         * @param {LibraryApiGetLibraryOptionsInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLibraryOptionsInfo(requestParameters = {}, options) {
            return localVarFp.getLibraryOptionsInfo(requestParameters.libraryContentType, requestParameters.isNewLibrary, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Gets all user media folders.
         * @param {LibraryApiGetMediaFoldersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMediaFolders(requestParameters = {}, options) {
            return localVarFp.getMediaFolders(requestParameters.isHidden, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Gets a list of physical paths from virtual folders.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhysicalPaths(options) {
            return localVarFp.getPhysicalPaths(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Gets similar items.
         * @param {LibraryApiGetSimilarAlbumsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimilarAlbums(requestParameters, options) {
            return localVarFp.getSimilarAlbums(requestParameters.itemId, requestParameters.excludeArtistIds, requestParameters.userId, requestParameters.limit, requestParameters.fields, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Gets similar items.
         * @param {LibraryApiGetSimilarArtistsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimilarArtists(requestParameters, options) {
            return localVarFp.getSimilarArtists(requestParameters.itemId, requestParameters.excludeArtistIds, requestParameters.userId, requestParameters.limit, requestParameters.fields, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Gets similar items.
         * @param {LibraryApiGetSimilarItemsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimilarItems(requestParameters, options) {
            return localVarFp.getSimilarItems(requestParameters.itemId, requestParameters.excludeArtistIds, requestParameters.userId, requestParameters.limit, requestParameters.fields, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Gets similar items.
         * @param {LibraryApiGetSimilarMoviesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimilarMovies(requestParameters, options) {
            return localVarFp.getSimilarMovies(requestParameters.itemId, requestParameters.excludeArtistIds, requestParameters.userId, requestParameters.limit, requestParameters.fields, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Gets similar items.
         * @param {LibraryApiGetSimilarShowsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimilarShows(requestParameters, options) {
            return localVarFp.getSimilarShows(requestParameters.itemId, requestParameters.excludeArtistIds, requestParameters.userId, requestParameters.limit, requestParameters.fields, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Gets similar items.
         * @param {LibraryApiGetSimilarTrailersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimilarTrailers(requestParameters, options) {
            return localVarFp.getSimilarTrailers(requestParameters.itemId, requestParameters.excludeArtistIds, requestParameters.userId, requestParameters.limit, requestParameters.fields, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get theme songs and videos for an item.
         * @param {LibraryApiGetThemeMediaRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThemeMedia(requestParameters, options) {
            return localVarFp.getThemeMedia(requestParameters.itemId, requestParameters.userId, requestParameters.inheritFromParent, requestParameters.sortBy, requestParameters.sortOrder, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get theme songs for an item.
         * @param {LibraryApiGetThemeSongsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThemeSongs(requestParameters, options) {
            return localVarFp.getThemeSongs(requestParameters.itemId, requestParameters.userId, requestParameters.inheritFromParent, requestParameters.sortBy, requestParameters.sortOrder, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get theme videos for an item.
         * @param {LibraryApiGetThemeVideosRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThemeVideos(requestParameters, options) {
            return localVarFp.getThemeVideos(requestParameters.itemId, requestParameters.userId, requestParameters.inheritFromParent, requestParameters.sortBy, requestParameters.sortOrder, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Reports that new movies have been added by an external source.
         * @param {LibraryApiPostAddedMoviesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAddedMovies(requestParameters = {}, options) {
            return localVarFp.postAddedMovies(requestParameters.tmdbId, requestParameters.imdbId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Reports that new episodes of a series have been added by an external source.
         * @param {LibraryApiPostAddedSeriesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAddedSeries(requestParameters = {}, options) {
            return localVarFp.postAddedSeries(requestParameters.tvdbId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Reports that new movies have been added by an external source.
         * @param {LibraryApiPostUpdatedMediaRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUpdatedMedia(requestParameters, options) {
            return localVarFp.postUpdatedMedia(requestParameters.mediaUpdateInfoDto, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Reports that new movies have been added by an external source.
         * @param {LibraryApiPostUpdatedMoviesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUpdatedMovies(requestParameters = {}, options) {
            return localVarFp.postUpdatedMovies(requestParameters.tmdbId, requestParameters.imdbId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Reports that new episodes of a series have been added by an external source.
         * @param {LibraryApiPostUpdatedSeriesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUpdatedSeries(requestParameters = {}, options) {
            return localVarFp.postUpdatedSeries(requestParameters.tvdbId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Starts a library scan.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshLibrary(options) {
            return localVarFp.refreshLibrary(options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * LibraryApi - object-oriented interface
 * @export
 * @class LibraryApi
 * @extends {BaseAPI}
 */
class LibraryApi extends BaseAPI {
    /**
     *
     * @summary Deletes an item from the library and filesystem.
     * @param {LibraryApiDeleteItemRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    deleteItem(requestParameters, options) {
        return LibraryApiFp(this.configuration).deleteItem(requestParameters.itemId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Deletes items from the library and filesystem.
     * @param {LibraryApiDeleteItemsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    deleteItems(requestParameters = {}, options) {
        return LibraryApiFp(this.configuration).deleteItems(requestParameters.ids, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Gets all parents of an item.
     * @param {LibraryApiGetAncestorsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    getAncestors(requestParameters, options) {
        return LibraryApiFp(this.configuration).getAncestors(requestParameters.itemId, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Gets critic review for an item.
     * @param {LibraryApiGetCriticReviewsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    getCriticReviews(requestParameters, options) {
        return LibraryApiFp(this.configuration).getCriticReviews(requestParameters.itemId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Downloads item media.
     * @param {LibraryApiGetDownloadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    getDownload(requestParameters, options) {
        return LibraryApiFp(this.configuration).getDownload(requestParameters.itemId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get the original file of an item.
     * @param {LibraryApiGetFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    getFile(requestParameters, options) {
        return LibraryApiFp(this.configuration).getFile(requestParameters.itemId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get item counts.
     * @param {LibraryApiGetItemCountsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    getItemCounts(requestParameters = {}, options) {
        return LibraryApiFp(this.configuration).getItemCounts(requestParameters.userId, requestParameters.isFavorite, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Gets the library options info.
     * @param {LibraryApiGetLibraryOptionsInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    getLibraryOptionsInfo(requestParameters = {}, options) {
        return LibraryApiFp(this.configuration).getLibraryOptionsInfo(requestParameters.libraryContentType, requestParameters.isNewLibrary, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Gets all user media folders.
     * @param {LibraryApiGetMediaFoldersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    getMediaFolders(requestParameters = {}, options) {
        return LibraryApiFp(this.configuration).getMediaFolders(requestParameters.isHidden, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Gets a list of physical paths from virtual folders.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    getPhysicalPaths(options) {
        return LibraryApiFp(this.configuration).getPhysicalPaths(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Gets similar items.
     * @param {LibraryApiGetSimilarAlbumsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    getSimilarAlbums(requestParameters, options) {
        return LibraryApiFp(this.configuration).getSimilarAlbums(requestParameters.itemId, requestParameters.excludeArtistIds, requestParameters.userId, requestParameters.limit, requestParameters.fields, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Gets similar items.
     * @param {LibraryApiGetSimilarArtistsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    getSimilarArtists(requestParameters, options) {
        return LibraryApiFp(this.configuration).getSimilarArtists(requestParameters.itemId, requestParameters.excludeArtistIds, requestParameters.userId, requestParameters.limit, requestParameters.fields, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Gets similar items.
     * @param {LibraryApiGetSimilarItemsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    getSimilarItems(requestParameters, options) {
        return LibraryApiFp(this.configuration).getSimilarItems(requestParameters.itemId, requestParameters.excludeArtistIds, requestParameters.userId, requestParameters.limit, requestParameters.fields, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Gets similar items.
     * @param {LibraryApiGetSimilarMoviesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    getSimilarMovies(requestParameters, options) {
        return LibraryApiFp(this.configuration).getSimilarMovies(requestParameters.itemId, requestParameters.excludeArtistIds, requestParameters.userId, requestParameters.limit, requestParameters.fields, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Gets similar items.
     * @param {LibraryApiGetSimilarShowsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    getSimilarShows(requestParameters, options) {
        return LibraryApiFp(this.configuration).getSimilarShows(requestParameters.itemId, requestParameters.excludeArtistIds, requestParameters.userId, requestParameters.limit, requestParameters.fields, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Gets similar items.
     * @param {LibraryApiGetSimilarTrailersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    getSimilarTrailers(requestParameters, options) {
        return LibraryApiFp(this.configuration).getSimilarTrailers(requestParameters.itemId, requestParameters.excludeArtistIds, requestParameters.userId, requestParameters.limit, requestParameters.fields, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get theme songs and videos for an item.
     * @param {LibraryApiGetThemeMediaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    getThemeMedia(requestParameters, options) {
        return LibraryApiFp(this.configuration).getThemeMedia(requestParameters.itemId, requestParameters.userId, requestParameters.inheritFromParent, requestParameters.sortBy, requestParameters.sortOrder, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get theme songs for an item.
     * @param {LibraryApiGetThemeSongsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    getThemeSongs(requestParameters, options) {
        return LibraryApiFp(this.configuration).getThemeSongs(requestParameters.itemId, requestParameters.userId, requestParameters.inheritFromParent, requestParameters.sortBy, requestParameters.sortOrder, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get theme videos for an item.
     * @param {LibraryApiGetThemeVideosRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    getThemeVideos(requestParameters, options) {
        return LibraryApiFp(this.configuration).getThemeVideos(requestParameters.itemId, requestParameters.userId, requestParameters.inheritFromParent, requestParameters.sortBy, requestParameters.sortOrder, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Reports that new movies have been added by an external source.
     * @param {LibraryApiPostAddedMoviesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    postAddedMovies(requestParameters = {}, options) {
        return LibraryApiFp(this.configuration).postAddedMovies(requestParameters.tmdbId, requestParameters.imdbId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Reports that new episodes of a series have been added by an external source.
     * @param {LibraryApiPostAddedSeriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    postAddedSeries(requestParameters = {}, options) {
        return LibraryApiFp(this.configuration).postAddedSeries(requestParameters.tvdbId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Reports that new movies have been added by an external source.
     * @param {LibraryApiPostUpdatedMediaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    postUpdatedMedia(requestParameters, options) {
        return LibraryApiFp(this.configuration).postUpdatedMedia(requestParameters.mediaUpdateInfoDto, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Reports that new movies have been added by an external source.
     * @param {LibraryApiPostUpdatedMoviesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    postUpdatedMovies(requestParameters = {}, options) {
        return LibraryApiFp(this.configuration).postUpdatedMovies(requestParameters.tmdbId, requestParameters.imdbId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Reports that new episodes of a series have been added by an external source.
     * @param {LibraryApiPostUpdatedSeriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    postUpdatedSeries(requestParameters = {}, options) {
        return LibraryApiFp(this.configuration).postUpdatedSeries(requestParameters.tvdbId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Starts a library scan.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    refreshLibrary(options) {
        return LibraryApiFp(this.configuration).refreshLibrary(options).then((request) => request(this.axios, this.basePath));
    }
}

export { LibraryApi, LibraryApiAxiosParamCreator, LibraryApiFactory, LibraryApiFp };
